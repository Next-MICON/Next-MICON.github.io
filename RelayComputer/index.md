# リレーコンピュータ

![](RelayAdder.jpeg)

コンピュータといえば半導体と思われがちですが，実は半導体が登場する数十年前からコンピュータはありました．リレーコンピュータもそんな前半導体時代のコンピュータのひとつです．[^0]

[^0]: 正確には電子計算機といったほうがよろしいでしょう．というのも，コンピュータという言葉は電子計算機だけではなく，広く「計算する者」を指す言葉だからです．実際に，コンピュータ（計算手）という，手計算をする仕事がありました． [計算手の写真](https://upload.wikimedia.org/wikipedia/commons/0/06/Human_computers_-_Dryden.jpg)

## リレーとは？

電磁石で動くスイッチです．[^1]

![](./img/relay.drawio.svg)

[^1]: 論理回路の素子として必要な性質は「電気で制御可能なスイッチ」であることです．

## しくみ

概要図

![](./img/arch.drawio.svg)

### 1. クロックジェネレータ

電源を入れると，まずクロックジェネレータが動きだし，クロック信号を生成します．

![](./img/clock.drawio.svg)

リレーが OFF 状態のときは，コンデンサに充電され，リレーのコイルにかかる電圧は上昇します．ある電圧に達したとき，リレーが ON 状態になり，電源の供給が絶たれます．しばらくリレーは ON 状態にありますが，コンデンサの放電が進み電圧が下がるとリレーが OFF 状態になり，最初に戻ります．

![](./img/clock-gen.drawio.svg)

### 2. プログラムカウンタ

クロック信号のパルスが来るごとに，カウントアップします．

![](./img/program-counter.drawio.svg)

### 3. プログラムメモリ

プログラムカウンタの番地に書いてある命令を取り出します．

![](./img/program-memory.drawio.svg)

### 4. 命令デコーダ

命令を読み解いて，指示をだします．

|             | 命令の種類 | 引数 1   | 引数 2   |
| ----------- | ---------- | -------- | -------- |
|             | 2 ビット   | 8 ビット | 8 ビット |
| NoOperation | 00         | -        | -        |
| JumpIf      | 01         | 分岐条件 | 分岐先   |
| Move        | 10         | 参照元   | 書込先   |
| Load        | 11         | 即値     | 書込先   |

### 5. 命令の実行

命令の内容に応じていろいろな動作をします．

#### (0) NoOperation

何もしません．１クロックの時間を無為に過ごします．

#### (1) JumpIf

プログラムの分岐とジャンプを行います．

プログラムカウンタを書き換えます．

#### (2) Move

参照元から値を取ってきて，書込先に上書きします．

#### (3) Load

即値を，書込先に上書きします．

### 5. 裏方の仕事

ここが一番重要です

### 6. そして次の命令へ

## アーキテクチャの解説（まじめ）

このコンピュータのアーキテクチャは「いろいろなプログラムに対して早く動く」という野望をもとに設計しました．

コア部分の機能を絞り，拡張モジュールで機能を柔軟に変化できるアーキテクチャ

1. 簡潔な命令セットでクロック周波数を高速化
2. 計算モジュールを交換することで，問題に対して柔軟なハードウェア構成
3. モジュール並列化することで，計算のボトルネックを解消する

![](arch.drawio.svg)

| Function | OP  | OPR1       | OPR2          |
| -------- | --- | ---------- | ------------- |
| NOP      | 00  | -          | -             |
| JMPIF    | 01  | Condition  | JumpTo        |
| MOV      | 10  | SourceAddr | DirectionAddr |
| LOAD     | 11  | Immidiate  | DirectionAddr |

1. ハードウェアとソフトウェアの双対性

## 計算機って何？ 計算って何？

とりあえず，脳内で以下の作業をしてみてください．

![](./img/sugoroku1.drawio.svg)

最後に持っている大福の数が 3 × 2 の答えになっていますが[^2]，さて，この作業をした人は掛け算を理解しているでしょうか．いや，掛け算を知らない人がこの作業をできるでしょうか．

[^2]: なぜこんなにまわりくどい方法をとっているのか．それは数や計算というのが抽象的な概念だからです．「2 つの大福」を手に取ることはできても，そこから「大福」を取り除いた「2 つ」を手にすることはできません．物理的実体のない「数」を，機械が扱える形に現すために，「2」を大福に憑依させているのです．そういう意味で，数は関数です．「2(x)」という関数は「2 つの x」という実体を返します．この関数は入れ子にすることができます．「3(2(x)) = 3(2 つの x) = 6 つの x」．つまりこれは「3(2(x)) = 6(x)」を表しています．これが，物理的実体に根ざした掛け算です．

掛け算を理解していなくとも，この作業を実行できます．この作業に必要なスキルと，掛け算のスキルは異なるからです．

実はコンピュータも，掛け算はおろか数を理解せずに，掛け算を計算しています．

### 無能か万能か

掛け算のかわりに足し算を繰り返すといったように．ある計算を別の計算の手続きとして置き換えることができます．

この置き換えを究極的に突き詰めた結果が，最小限のスキルであらゆる計算を行える「チューリングマシン」です．

「計算とは何か？」という問いに対してチューリングは，「最低限これができること」と答えたわけです．[^3]

[^3]: この問題に「計算とはラムダ計算だ」と答えたのがアメリカの数学者，アロンゾ・チャーチです．彼は，数と関数を同一視する「ラムダ式」という概念を作り，そこに「ラムダ式の簡約」を定義しました．「計算とは何か？」という問いに，チューリングはチューリングマシン，チャーチはラムダ計算と，全く別のアプローチで解答したわけですが，両者が実は同値であるということが証明されます．「計算」の盤石な定義を得た人類は計算機科学を発展させていくこととなるのです．

ある計算を，チューリングマシンが実行可能な手続きに書き換えることがプログラムです．

どんな計算も機械的な手続きで行える．その手続きを自動で行う機械が「チューリングマシン」，

## あとがき
